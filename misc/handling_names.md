# Handling names

The below provides a summary of how paricipant names are handled for the Bohemia project.

## 5 Principles
- There is no research value in participant names
- There is operational value in participant names
- Sites (CISM, IHI) can access and store participant names
- Sponor (ISGlobal) cannot store participant names
- Sponsor-contracted third parties (Databrew) cannot store participant names

## The problem

The first four of the above five problems pose no problems. However, the fifth principle is slightly problematic. The reason is that the sponsor-contracted third party (Databrew) needs to generate digital forms in which names are included (ie, fieldworkers need to select a household and household member, and pre-populate certain fields based on the selection). In order for Databrew to put a name on a form Databrew needs access to that name.

### Side-note: Why not just use the local site databases?

If the third-party contractor cannot store names, but sites can, why not just use the names data from the site databases to populate forms? The reason is that Databrew carries out data processing tasks which sometimes result in the alteration of an incorrectly-enumerated participant ID number or the removal of a duplicated participant. These alterations occur in the Databrew database, but do not get copied over to the site databases (since the site databases are unmodified/raw). Therefore, if the tablets relied solely on the names data from the site databases, they may end up with duplicates and errors.

## The solution

We propose a solution wherein:
- The Databrew-maintained central database is split into two:
  - 1. The "consortium database" (for operational purposes) which includes name variables but only after prior hashing (ie, conversion to a format which can only be backwards-engineered using a de-encryption key)
  - 2. The "study database" (for research purposes) which includes no name variables

The below shows a schema of the data flow.

![](img/names.png)

### Principles of the solution

- Data is sent (with names) from tablets to the site databases.
- An automated script retrieves data from the site databases, process/formats that data, and hashes all names. Following hashing, data is saved into the "consortium database" where it undergoes structured modifications (data cleaning) which are logged.  
- When a new form needs to be generated, Databrew uses the "consortium database" to generate certain multiple choice fields which require names. Because these names are hashes in the database, the form generated by Databrew contains choices that look like this (example only):

Question 13: Select the member of the household

```
A. 8s7df8a7ds68ashasdhp
B. a;ldfh9asdfsa232l2j;
C. 2l;j2g3iu2;os9-dlls1
D. dsa0s92n-2jp2on3h12%
```

- When the sites retrieve the forms created by Databrew, they use the combination of (a) a de-encryption script provided by Databrew and (b) a de-encryption key file to convert values like `dsa0s92n-2jp2on3h12%` to `Wanjiru Kimani`.  
- Following conversion, the sites upload the the (de-encrypted) form to their local ODK forms server.  
- Since the de-encrypted form contains human-readable names, the tablets will be able to include names in the drop-downs in the following format:

Question 13: Select the member of the household

```
A. John Doe
B. Jane Doe
C. Alice Doe
D. Wanjiru Kimani
```

## Comment on the "de-encryption key"

- The "de-encryption key" is essentially a (very long) password. Without it, names are indecipherable.  
- Databrew generates the de-encryption key and gives one copy to each site (3 copies total).  
- Databrew retains a copy of the key only for the purpose of ensuring that data is not lost in the case of a site mishap. Only one Databrew team member will have access to the key.
- Databrew will not use the key; it is retained solely for the purpose of supplying to the site.
- If the database is accessed using the de-encryption key, the event will be logged, considered a breach, and reported to the sponsor.  

# Encryption key generation  

The databrew `bohemia` package includes utilites for generating encryption / de-encryption keys. Below is a walk-through.

```
library(bohemia)

# Generate encryption keys
generate_keys(dir = '../credentials/')

```

Once the public and private keys have been generated, they can be used to encrypt and de-encrypt data, respectively. For example:

```
library(bohemia)

some_names <- c('Joe Brew', 'Wanjiru Kimani', 'Jaume Rovirosa')
encrypted <- encrypt_private_data(data = some_names,
                                                keyfile = '../credentials/bohemia_pub.pem')
print(encrypted)
decrypted <- decrypt_private_data(encrypted,
                                           keyfile = '../credentials/bohemia_priv.pem')
print(decrypted)
```

# How to Decrypt CSV File

As a data manager, you can decrypt the data from a csv file by doing the following steps in your RStudio

1. Open the file `decrypt_csv_data.R` it contains the following code snippet:

```
suppressMessages({
    library(bohemia)
})

csv_file <- 'tmp/itemsets.csv'
enc_columns <- list('fname','lname')
keyfile <- 'rpackage/bohemia/bohemia_priv.pem'


csv_contents <- read.csv(csv_file, TRUE, sep=',')
enc_columns <- unlist(enc_columns)

for(col_name in enc_columns){
    col_content <- csv_contents[[col_name]]
    dec_content <- decrypt_private_data(col_content, keyfile)
    csv_contents[[col_name]] <- dec_content
}

readr::write_csv(csv_contents, file = "decrypted_csv_data.csv")
message("Decrypted csv file title 'decrypted_csv_data.csv' created at: ", getwd())
```

2. Set the applicable values for the params i.e. `csv_file, enc_columns, keyfile`:
  - `csv_file` is the path to your data file that has encrypted data
  - `enc_columns` is the list of column headings that have the encrypted data. 
  - `keyfile` is the path to your pem file containing the secret key

3. Run the R code

4. In the directory indicated by the message, open the file `decrypted_csv_data.csv` and move it 
   to your desired location and rename it as you prefer.
   _Please note that every time you run this R script, the decrypted file's contents are overwritten_
